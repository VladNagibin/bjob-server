{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "contracts/IJobOfferFactoryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {Currency} from \"./PriceConventer.sol\";\n\ninterface IJobOfferFactory {\n    enum OfferType {\n        HOURLY,\n        SALARY\n    }\n\n    function fundJobOffer(uint256 amount, address employerAddress, bool keeperCompatible) external;\n\n    function createJobOffer(\n        OfferType contractType,\n        uint256 paymentAmount,\n        address employeeAddress,\n        uint256 paymentRate,\n        Currency currency\n    ) external returns (address);\n}\n"
    },
    "contracts/JobOffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./PriceConventer.sol\";\nimport {IJobOfferFactory} from \"./IJobOfferFactoryInterface.sol\";\n\nerror JobOffer_not_enough_amount(uint256 requiredAmount, Currency currency);\nerror JobOffer_not_employee();\nerror JobOffer_not_employer();\nerror JobOffer_invalid_sender();\nerror JobOffer_transaction_not_successful();\nerror JobOffer_payment_not_needed();\nerror JobOffer_wrong_offer_type();\nerror JobOffer_is_not_keeper_compatible();\nerror JobOffer_not_closed();\nerror JobOffer_wrong_state();\n\nenum OfferType {\n    HOURLY,\n    SALARY\n}\n\nstruct OfferBetween {\n    address employeeAddress;\n    address employerAddress;\n}\n\nstruct PriceFeeds {\n    AggregatorV3Interface priceFeedUSDtoETH;\n    AggregatorV3Interface priceFeedUSDtoEUR;\n}\n\nstruct Settings {\n    uint256 paymentAmount;\n    uint256 paymentRate;\n    Currency currency;\n    uint256 requiredSalariesFunded;\n    OfferType offerType;\n    bool keeperCompatible;\n}\nenum JobOfferState {\n    UNSIGNED,\n    ACTIVE,\n    CLOSED\n}\n\ncontract JobOffer {\n    using PriceConventer for uint256;\n\n    event ContractSigned(address indexed employee, uint256 timestamp);\n    event SalaryPaid(address indexed employee, uint256 ethAmount, uint256 timestamp);\n    event ContractClosed(JobOfferState indexed state, address indexed closedBy, uint256 timestamp);\n    event ContractNeedsToBeFunded(address indexed contractAddress, uint256 ethAmount);\n\n    uint256 private immutable i_paymentAmount;\n    address private immutable i_companyAddress;\n    address private immutable i_employeeAddress;\n    IJobOfferFactory private immutable i_jobOfferFactory;\n    Currency private immutable i_currency;\n    uint256 private immutable i_paymentRate;\n    OfferType private immutable i_offerType;\n    bool private immutable i_keeperCompatible;\n\n    uint256 private s_nonPaidWorkedHours;\n    AggregatorV3Interface private s_priceFeedUSDtoETH;\n    AggregatorV3Interface private s_priceFeedUSDtoEUR;\n    uint256 private s_lastPaymentTimestamp;\n    JobOfferState private s_state;\n\n    modifier onlyEmployer() {\n        if (msg.sender != i_companyAddress) {\n            revert JobOffer_not_employer();\n        }\n        _;\n    }\n\n    modifier onlyEmployee() {\n        if (msg.sender != i_employeeAddress) {\n            revert JobOffer_not_employee();\n        }\n        _;\n    }\n\n    modifier payment() {\n        if (s_lastPaymentTimestamp + i_paymentRate > block.timestamp) {\n            revert JobOffer_payment_not_needed();\n        }\n        _;\n    }\n\n    modifier active() {\n        if (s_state != JobOfferState.ACTIVE) {\n            revert JobOffer_wrong_state();\n        }\n        _;\n    }\n\n    modifier hourly() {\n        if (i_offerType == OfferType.SALARY) {\n            revert JobOffer_wrong_offer_type();\n        }\n        _;\n    }\n\n    modifier salary() {\n        if (i_offerType == OfferType.HOURLY) {\n            revert JobOffer_wrong_offer_type();\n        }\n        _;\n    }\n\n    constructor(\n        OfferBetween memory offerBetween,\n        PriceFeeds memory priceFeeds,\n        Settings memory settings\n    ) payable {\n        i_currency = settings.currency;\n        s_priceFeedUSDtoETH = priceFeeds.priceFeedUSDtoETH;\n        s_priceFeedUSDtoEUR = priceFeeds.priceFeedUSDtoEUR;\n        uint256 requiredAmountFunded = (settings.paymentAmount *\n            settings.requiredSalariesFunded *\n            95) / 100;\n        if (i_currency != Currency.ETH) {\n            if (\n                msg.value.getCurrencyAmount(s_priceFeedUSDtoETH, s_priceFeedUSDtoEUR, i_currency) <\n                requiredAmountFunded\n            ) {\n                revert JobOffer_not_enough_amount(requiredAmountFunded, settings.currency);\n            }\n        } else if (msg.value < requiredAmountFunded) {\n            revert JobOffer_not_enough_amount(requiredAmountFunded, settings.currency);\n        }\n        i_keeperCompatible = settings.keeperCompatible;\n        i_offerType = settings.offerType;\n        i_paymentAmount = settings.paymentAmount;\n        i_paymentRate = settings.paymentRate;\n        i_employeeAddress = offerBetween.employeeAddress;\n        i_companyAddress = offerBetween.employerAddress;\n        s_state = JobOfferState.UNSIGNED;\n        s_lastPaymentTimestamp = 0;\n        i_jobOfferFactory = IJobOfferFactory(msg.sender);\n    }\n\n    function sign() public onlyEmployee returns (JobOfferState) {\n        if (s_state != JobOfferState.UNSIGNED) {\n            revert JobOffer_wrong_state();\n        }\n        s_state = JobOfferState.ACTIVE;\n        emit ContractSigned(i_employeeAddress, block.timestamp);\n        return s_state;\n    }\n\n    function close() public returns (JobOfferState) {\n        if (msg.sender == i_companyAddress || msg.sender == i_employeeAddress) {\n            s_state = JobOfferState.CLOSED;\n            emit ContractClosed(s_state, msg.sender, block.timestamp);\n            return s_state;\n        }\n        revert JobOffer_invalid_sender();\n    }\n\n    function pay() internal returns (uint256) {\n        uint256 paymentAmount = i_paymentAmount;\n        if (i_currency != Currency.ETH) {\n            paymentAmount = paymentAmount.getEthAmount(\n                s_priceFeedUSDtoETH,\n                s_priceFeedUSDtoEUR,\n                i_currency\n            );\n        }\n        if (i_offerType == OfferType.HOURLY) {\n            paymentAmount *= s_nonPaidWorkedHours;\n        }\n        (bool success, ) = i_employeeAddress.call{value: paymentAmount}(\"\");\n        if (!success) {\n            revert JobOffer_transaction_not_successful();\n        }\n        try\n            i_jobOfferFactory.fundJobOffer(paymentAmount, i_companyAddress, i_keeperCompatible)\n        {} catch {\n            emit ContractNeedsToBeFunded(address(this), paymentAmount);\n        }\n        s_lastPaymentTimestamp = block.timestamp;\n        emit SalaryPaid(i_employeeAddress, paymentAmount, block.timestamp);\n        s_nonPaidWorkedHours = 0;\n        return paymentAmount;\n    }\n\n    function setWorkedHours(\n        uint256 workedHours\n    ) public onlyEmployee active hourly returns (uint256) {\n        s_nonPaidWorkedHours += workedHours;\n        return s_nonPaidWorkedHours;\n    }\n\n    function payWorkedHours() public onlyEmployee payment hourly returns (uint256) {\n        return pay();\n    }\n\n    function payMonthly() public onlyEmployer payment salary active returns (uint256) {\n        return pay();\n    }\n\n    function performUpkeep() public payment active returns (uint256) {\n        if (!i_keeperCompatible) {\n            revert JobOffer_is_not_keeper_compatible();\n        }\n        return pay();\n    }\n\n    function withdraw() public onlyEmployer {\n        if (s_state != JobOfferState.CLOSED) {\n            revert JobOffer_not_closed();\n        }\n        uint256 balance = address(this).balance;\n        if (i_offerType == OfferType.HOURLY) {\n            balance -=\n                i_paymentAmount.getEthAmount(s_priceFeedUSDtoETH, s_priceFeedUSDtoEUR, i_currency) *\n                s_nonPaidWorkedHours;\n        }\n        (bool success, ) = payable(i_companyAddress).call{value: balance}(\"\");\n        if (!success) {\n            revert JobOffer_transaction_not_successful();\n        }\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    function getWorkedHours() public view returns (uint256) {\n        return s_nonPaidWorkedHours;\n    }\n\n    function getLastPaymentTimestamp() external view returns (uint256) {\n        return s_lastPaymentTimestamp;\n    }\n\n    function getPaymentRate() external view returns (uint256) {\n        return i_paymentRate;\n    }\n\n    function getPaymentAmount() external view returns (uint256) {\n        return i_paymentAmount;\n    }\n\n    function getState() external view returns (JobOfferState) {\n        return s_state;\n    }\n\n    function getCurrency() external view returns (Currency) {\n        return i_currency;\n    }\n\n    function getEthAmount() external view returns (uint256) {\n        return i_paymentAmount.getEthAmount(s_priceFeedUSDtoETH, s_priceFeedUSDtoEUR, i_currency);\n    }\n\n    function getEmployeeAddress() external view returns (address) {\n        return i_employeeAddress;\n    }\n\n    function getEmployerAddress() external view returns (address) {\n        return i_companyAddress;\n    }\n\n    function isKeeperCompatible() external view returns (bool) {\n        return i_keeperCompatible;\n    }\n}\n"
    },
    "contracts/JobOfferFactory.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.8.17;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\n\nimport {PriceConventer, Currency} from \"./PriceConventer.sol\";\nimport {JobOffer, OfferType, Settings, OfferBetween, PriceFeeds, JobOfferState} from \"./JobOffer.sol\";\n\nerror JobOfferFactory_transaction_not_successful();\nerror JobOfferFactory_not_enough_eth_funded(uint256 requiredEthAmount, uint256 balance);\nerror JobOfferFactory_not_valid_offer(address offerAddress);\nerror JobOfferFactory_employer_does_not_have_enough_balance();\nerror JobOfferFactory_not_all_offers_closed();\nerror JobOfferFactory_zero_balance();\n\ncontract JobOfferFactory is KeeperCompatibleInterface {\n    using PriceConventer for uint256;\n\n    struct Employer {\n        uint256 balance;\n        Offer[] offers;\n    }\n\n    struct Employee {\n        Offer[] offers;\n    }\n\n    struct Offer {\n        address offerAddress;\n        OfferType offerType;\n    }\n\n    event OfferCreated(\n        address indexed offerAddress,\n        OfferType offerType,\n        address employer,\n        address employee\n    );\n\n    uint256 private constant REQUIRED_HOURS_FUNDED = 72 * 8;\n    uint256 private constant REQUIRED_SALARIES_FUNDED = 3;\n    uint256 public constant KEEPER_COMPATIBLE_FEE = 5000000000000000;\n\n    AggregatorV3Interface private priceFeedUSDtoETH;\n    AggregatorV3Interface private priceFeedUSDtoEUR;\n    address private immutable owner;\n\n    mapping(address => Employer) private employerData;\n    mapping(address => Employee) private employeeData;\n\n    address[] private validOffers;\n\n    constructor(address priceFeedUSDtoETHAddress, address priceFeedEURtoUSDAddress) {\n        priceFeedUSDtoETH = AggregatorV3Interface(priceFeedUSDtoETHAddress);\n        priceFeedUSDtoEUR = AggregatorV3Interface(priceFeedEURtoUSDAddress);\n        owner = msg.sender;\n    }\n\n    function fund() public payable {\n        employerData[msg.sender].balance += msg.value;\n    }\n\n    fallback() external payable {\n        fund();\n    }\n\n    receive() external payable {\n        fund();\n    }\n\n    function createJobOffer(\n        OfferType contractType,\n        uint256 paymentAmount,\n        address employeeAddress,\n        uint256 paymentRate,\n        Currency currency,\n        bool keeperCompatible\n    ) external returns (address) {\n        uint256 requiredSalariesFunded = REQUIRED_SALARIES_FUNDED;\n        if (contractType == OfferType.HOURLY) {\n            requiredSalariesFunded = REQUIRED_HOURS_FUNDED;\n        }\n        uint256 fee = 0;\n        if (keeperCompatible) {\n            fee = KEEPER_COMPATIBLE_FEE;\n        }\n        uint256 requiredEthAmount = paymentAmount.getEthAmount(\n            priceFeedUSDtoETH,\n            priceFeedUSDtoEUR,\n            currency\n        ) *\n            requiredSalariesFunded +\n            fee;\n        if (requiredEthAmount > employerData[msg.sender].balance) {\n            revert JobOfferFactory_not_enough_eth_funded(\n                requiredEthAmount,\n                employerData[msg.sender].balance\n            );\n        }\n        JobOffer offer = new JobOffer{value: requiredEthAmount - fee}(\n            OfferBetween(employeeAddress, msg.sender),\n            PriceFeeds(priceFeedUSDtoETH, priceFeedUSDtoEUR),\n            Settings(\n                paymentAmount,\n                paymentRate,\n                currency,\n                requiredSalariesFunded,\n                contractType,\n                keeperCompatible\n            )\n        );\n        employerData[msg.sender].balance -= requiredEthAmount;\n        if (keeperCompatible) {\n            payKeeperCompatibleFee();\n        }\n        employerData[msg.sender].offers.push(Offer((address(offer)), contractType));\n        employeeData[employeeAddress].offers.push(Offer((address(offer)), contractType));\n        validOffers.push(address(offer));\n        emit OfferCreated(address(offer), contractType, msg.sender, employeeAddress);\n        return address(offer);\n    }\n\n    function fundJobOffer(uint256 amount, address employerAddress, bool keeperCompatible) external {\n        if (!isValidOffer(msg.sender)) {\n            revert JobOfferFactory_not_valid_offer(msg.sender);\n        }\n        uint256 fee = 0;\n        if (keeperCompatible) {\n            fee = KEEPER_COMPATIBLE_FEE;\n            payKeeperCompatibleFee();\n        }\n        if (employerData[employerAddress].balance < amount + fee) {\n            revert JobOfferFactory_employer_does_not_have_enough_balance();\n        }\n        employerData[employerAddress].balance -= amount + fee;\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        if (!success) {\n            revert JobOfferFactory_transaction_not_successful();\n        }\n    }\n\n    function isValidOffer(address offerAddress) internal view returns (bool) {\n        for (uint8 i = 0; i < validOffers.length; i++) {\n            if (validOffers[i] == offerAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function countRequiredFund(\n        uint256 amount,\n        Currency currency,\n        OfferType offerType,\n        bool keeperCompatible\n    ) external view returns (uint256) {\n        uint256 requiredSalariesFunded = REQUIRED_SALARIES_FUNDED;\n        if (offerType == OfferType.HOURLY) {\n            requiredSalariesFunded = REQUIRED_HOURS_FUNDED;\n        }\n        uint256 fee = 0;\n        if (keeperCompatible) {\n            fee = KEEPER_COMPATIBLE_FEE;\n        }\n        return\n            amount.getEthAmount(priceFeedUSDtoETH, priceFeedUSDtoEUR, currency) *\n            requiredSalariesFunded +\n            fee;\n    }\n\n    function parseEthToCurrency(uint256 amount, Currency currency) external view returns (uint256) {\n        return amount.getCurrencyAmount(priceFeedUSDtoETH, priceFeedUSDtoEUR, currency);\n    }\n\n    function checkUpkeep(\n        bytes memory /*checkData*/\n    ) public pure override returns (bool upkeepNeeded, bytes memory /*performData*/) {\n        upkeepNeeded = true;\n    }\n\n    function performUpkeep(bytes calldata /* performData */) external override {\n        for (uint8 i = 0; i < validOffers.length; i++) {\n            JobOffer offer = JobOffer(payable(validOffers[i]));\n            if (!offer.isKeeperCompatible()) {\n                continue;\n            }\n            offer.performUpkeep();\n        }\n    }\n\n    function payKeeperCompatibleFee() internal {\n        (bool success, ) = payable(owner).call{value: KEEPER_COMPATIBLE_FEE}(\"\");\n        if (!success) {\n            revert JobOfferFactory_transaction_not_successful();\n        }\n    }\n\n    function isAllOffersClosed(address employer) internal view returns (bool) {\n        for (uint8 i = 0; i < employerData[employer].offers.length; i++) {\n            if (\n                JobOffer(payable(employerData[employer].offers[i].offerAddress)).getState() !=\n                JobOfferState.CLOSED\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function withdraw() public {\n        if (employerData[msg.sender].balance == 0) {\n            revert JobOfferFactory_zero_balance();\n        }\n        if (!isAllOffersClosed(msg.sender)) {\n            revert JobOfferFactory_not_all_offers_closed();\n        }\n        (bool success, ) = payable(msg.sender).call{value: employerData[msg.sender].balance}(\"\");\n        if (!success) {\n            revert JobOfferFactory_transaction_not_successful();\n        }\n    }\n\n    function getEmployerData() external view returns (Employer memory) {\n        return employerData[msg.sender];\n    }\n\n    function getEmployeeData() external view returns (Employee memory) {\n        return employeeData[msg.sender];\n    }\n\n    function getKeeperCompatibleFee() external pure returns (uint256) {\n        return KEEPER_COMPATIBLE_FEE;\n    }\n}\n"
    },
    "contracts/PriceConventer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nenum Currency {\n    ETH,\n    USD,\n    EUR\n}\n\nlibrary PriceConventer {\n    function getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256, uint8) {\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        uint8 decimals = priceFeed.decimals();\n        return (uint256(price), decimals);\n    }\n\n    function getCurrencyAmount(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeedUSDtoETH,\n        AggregatorV3Interface priceFeedUSDtoEUR,\n        Currency currency\n    ) internal view returns (uint256) {\n        if (currency == Currency.ETH) {\n            return ethAmount;\n        } else if (currency == Currency.USD) {\n            (uint256 ethPrice, uint8 priceDecimals) = getPrice(priceFeedUSDtoETH);\n            uint256 amountInCurrency = (ethPrice * ethAmount) / (10 ** priceDecimals);\n            return amountInCurrency;\n        } else {\n            (uint256 ethPrice, uint8 priceDecimals) = getPrice(priceFeedUSDtoETH);\n            (uint256 eurPrice, ) = getPrice(priceFeedUSDtoEUR);\n            uint256 rate = (ethPrice * (10 ** priceDecimals)) / eurPrice;\n            uint256 amountInCurrency = (ethAmount / (10 ** priceDecimals)) * rate;\n            return amountInCurrency;\n        }\n    }\n\n    function getEthAmount(\n        uint256 amountInCurrency,\n        AggregatorV3Interface priceFeedUSDtoETH,\n        AggregatorV3Interface priceFeedUSDtoEUR,\n        Currency currency\n    ) internal view returns (uint256) {\n        if (currency == Currency.ETH) {\n            return amountInCurrency;\n        } else if (currency == Currency.USD) {\n            (uint256 ethPrice, uint8 priceDecimals) = getPrice(priceFeedUSDtoETH);\n            uint256 ethAmount = amountInCurrency / ethPrice;\n            return ethAmount * (10 ** priceDecimals);\n        } else {\n            (uint256 ethPrice, uint8 priceDecimals) = getPrice(priceFeedUSDtoETH);\n            (uint256 eurPrice, ) = getPrice(priceFeedUSDtoEUR);\n            uint256 rate = (ethPrice * (10 ** priceDecimals)) / eurPrice;\n            uint256 ethAmount = amountInCurrency / rate;\n            return ethAmount * (10 ** priceDecimals);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}